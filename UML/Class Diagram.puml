@startuml
'Configuration'

skinparam style strictuml
skinparam genericDisplay old
skinparam linetype polyline
skinparam linetype ortho
hide empty members


'Controller package'
package "Controller Module"  {
class GameBoardController {
  -gameBoardView: Viewable
  -board: GameBoard
}

class ScoreBoardController {
    -scoreBoardView Viewable
    -board: ScoreBoard
}

class CardController {
    -cardView: Viewable
    -card: Card
}


class NightmareReferenceCardController {
    -referenceCard: NightmareReferenceCard
    -nightmarReferenceCardView: Viewable
}

class GameController{
    - firstSheep: IFirstSheep
    - Scanner: scanner
    - gameView: Viewable
    - controllers: ArrayList<Object>

    - generateControllers(): void
    - generateRestOfModel(): void
}
'TODO: Figure out where to initialize those 4 classes (probably not in the IGameController as we can't pass Model objects through the Controllers)'
'IChoose<T> maybe useful'
'IPlayer, Phase, Deck, Rulebook'
'IPlayer is created by First Sheep Controller. Phase knows IFirstSheep (and is created by IFirstSheep), and Phase knows NightmareReferenceCard'

class FirstSheepController {
    -firstSheepView: Viewable
    -firstSheep: FirstSheep
}
interface IGameController<<Interface>>{
    + initializeGame(): void
    + updateGameView(): void
}
class GameController implements IGameController

}


'View package'
package "View Module"  {
class GameBoardView {
    -controller: GameBoardController
    -board: GameBoard
}

interface Viewable<<Interface>> {
    + display(): void
    + requestUpdate(): void
    + input(): void
}
class NightmareReferenceCardView {
    -controller: NightmareReferenceCardController
}

class CardView {
    - Controller: CardController
}
class ScoreBoardView {
    -controller: ScoreBoardController
}
class FirstSheepView {
    -controller: FirstSheepController
}

class GameView{
    + views: ArrayList<view>
}

class NightmareReferenceCardView implements Viewable
class GameView implements Viewable
class CardView implements Viewable
class GameBoardView implements Viewable
class ScoreBoardView implements Viewable
class NightmareReferenceCardView implements Viewable
class FirstSheepView implements Viewable
}






package "Model Module"{
GameBoard "1"-"1" GameBoardController

class GameBoard {
  -dreamTilesArray: DreamTile[11]
  -cardDeck: Deck
  -dreamTileDeck: Deck
  -SIZE: int
}


class ScoreBoard {
  -SIZE: int
}



'TODO: Change this'
abstract class Deck<T><<Abstract>> {
  - deck: ArrayList<T>
  - draw: DrawFromDeck
  + createDeck(): void
}

interface Drawable<T><<Interface>>{
    + draw(Deck): T
}

class DrawFromDeck<T> implements Drawable{
    - rand: Random
}

class CardDeck<T> {
  -numberOfPlayers: int
  +chooseCards(int): void
}

class DreamTileDeck<T> {
  +revealMarket(): void
  -marketArray: DreamTile[4]
}

class CardDeck extends Deck
class DreamTileDeck extends Deck

abstract class Card<T><<Abstract>>  {
  + description: String
}


class SheepCard {
  - minimumPlayersRequired: int
  - winks: int
  - movableDistance: int
  - canMoveAndCatch: boolean
  - canMoveAndGain: boolean
}

class NightmareCard {
  -jump: boolean
  -walk: boolean
  -scareAdjacent: boolean
  -moveToWebToken: boolean
}

class SheepCard extends Card
class NightmareCard extends Card
class NightmareReferenceCard extends Card


abstract class NightmareReferenceCard {
    -nightmareToken:NightmareToken
    + InitializeToken(): void
}


class NightmareWolf {

}
interface ISinisterSpider<<Interface>> {
    + createWebToken(): void
}
class SinisterSpider implements ISinisterSpider {
    - webToken: IWebToken
}

class BumpInTheNight {

}
class NightmareWolf extends NightmareReferenceCard
class SinisterSpider extends NightmareReferenceCard
class BumpInTheNight extends NightmareReferenceCard


interface IDreamTile<T><<Interface>> {
    +activateTile(IPlayer):void
}

class DreamTile implements IDreamTile, IScare{
    - description: String
    - initialZzzsRequired:int
    -tokens:ArrayList<ZzzToken>
}


abstract class Token<<Abstract>>  {
  - position: int
  + setPosition(int): void
  + getPosition(): int
}

interface IZzzToken<<Interface>> {
    +setPlayer(IPlayer):void
    +getPlayer(IPlayer):void
}

class ZzzToken implements IZzzToken {
  -infinite: boolean
  -player: IPlayer
}

interface ISheepToken <<Interface>> {
}

class SheepToken extends Token implements ISheepToken, Scareable, Stuckable {
    -scares: int
    -isStuck: boolean
    -isActive: boolean
    -player: IPlayer
    -fence: IFence
}

interface INightmareToken <<Interface>>{
}

class NightmareToken implements INightmareToken{
    -fence: IFence
}

interface IPillowToken <<Interface>> {
    + setPlayer(IPlayer): void
    + getPlayer(): IPlayer
}

class PillowToken implements IPillowToken{
    - player: IPlayer
}

interface IWinkToken <<Interface>> {
    +hasSurpassed():boolean
    +setPlayer(IPlayer):void
    +getPlayer():IPlayer
}

class WinkToken  implements IWinkToken{
    -pillowToken: IPillowToken
    -player: IPlayer
}

interface IWebToken <<Interface>> {
    +capture(Stuckable):void
}

class WebToken implements IWebToken{
}

class ZzzToken extends Token
class PillowToken extends Token
class NightmareToken extends Token
class WinkToken extends Token
class WebToken extends Token




interface Scarable <<Interface>> {
    +incrementScare(): void
    +decrementScare(): void
    +resetScare(): void
}

interface IScare <<Interface>>{
    +Scare(Scarable): void
}

class Scare implements IScare{
}

interface Stuckable <<Interface>>{
    +swapStuck(): void
}

class NightmareToken implements IScare

interface IPlayer<<Interface>> {
    +initializeTokens():void
}

class Player implements IPlayer {
    - winks: int
    - isOut: boolean
    - nightmareReference: NightmareReferenceCard
    - zzzTokens: ArrayList<IZzzToken>
    - sheepToken: ISheepToken
    - winkToken: IWinkToken
    - pillowToken: IPillowToken
}


interface IActionable <<Interface>> {
    +actionOnToken(T, Token):void
}
class Actionable  implements IActionable{

}



interface IHand<<Interface>> {
    +addCard(Card):void
    +getNumCards():int
    +resolveCard():String, T
}

class Hand implements IHand {
    -cardDeck: CardDeck
    -cards: ICard[2]
}



interface IFirstSheep<<Interface>> {
  + getCurrentTurn(): IPlayer
  + getTurnSequence(): ArrayList<IPlayer>
  + declareFirstSheep(): void
}


class FirstSheep implements IFirstSheep {
    -currentFirstSheep: IPlayer
    -player:ArrayList<IPlayer>
}



'TODO: Look into this'
abstract class Phase<<Abstract>> implements Switchable{
  - isPhaseOver(): boolean
  - players: ArrayList<Player>
  - deck: Deck
  - gameController: GameController
  - nightmareReferenceCard: NightmareReferenceCard
  + takeAction(IPlayer): void

}

interface Switchable<<Interface>> {
    switch(): void
}

class SwitchPhase implements Switchable{

}

class RacingPhase extends Phase{
    -fence: IFence
    -refereneTile: IReferenceTile
    -resetable: Resetable
    +enforceFullHand(IPlayer):void
}

class RestingPhase extends Phase {
    -firstSheep: FirstSheep
    +initializeMarket():void
    +updateMarket():void
    +placeTileOrCatch(IPlayer):void
}




interface IResetable<<Interface>> {
    +reset(IPlayer, NightmareReferenceCard, cardDeck): void
}

class Resetable implements IResetAble {

}


class Main{
    -gameController: IGameController
    main(): void
}





class Rulebook {
    + getRules(): String
    + setRules(String): void
}





interface IFence<<Interface>> {
    + passedThrough(Token):void
    - sheepPassed(Token):void
    - nightmarePassed(Token):void
}

class Fence implements IFence {
    -phase: Phase
    -numberOfPlayers: int
}


interface IReferenceTile<<Interface>> {
    + movePillow(Player): void
    - calculateDistanceToPillow(Token, Token): void
}

class ReferenceTile implements IReferenceTile {
    -players:ArrayList<IPlayer>
}



"View Module" -[hidden]- "Controller Module"
GameBoardView "1"-"1" GameBoardController

ScoreBoard "1"-"1" ScoreBoardController
ScoreBoardView "1"-"1" ScoreBoardController


CardView "1"-"1" CardController

'TODO: Look into this'
CardController "1"-"0..*" Card


SheepCard "1"-"1" CardController
NightmareCard "1"-"1" CardController

NightmareReferenceCard "1" - "1" NightmareReferenceCardController
NightmareReferenceCardView "1" - "1" NightmareReferenceCardController


NightmareReferenceCard --|> INightmareToken


Player --|> IActionable: use
NightmareReferenceCard --|> IActionable:use

Hand --|> Card
Player --|> IHand

FirstSheep "1" - "1" FirstSheepController
FirstSheepView "1" - "1" FirstSheepController

RestingPhase --|> IFirstSheep
RacingPhase <|--|> IFence
RacingPhase "1"--|>"1" IReferenceTile
RacingPhase --|> IResetable

Main -> IGameController
GameView "1..*" --> "6..*" Viewable
GameView "1"-"1" IGameController
Rulebook "1" - "1" IGameController
Phase "2"-"1" IGameController
Phase --|> IPlayer: use

IPlayer "1..4"-"1" IGameController
IFirstSheep "1"-"1" IGameController
Deck "2"-"1" IGameController
NightmareReferenceCardController "1"-"1" GameBoardController
NightmareReferenceCardController "1"-"1" IWebToken
Player --|> NightmareReferenceCard: use
GameBoardController "1"--|>"1..4" IPlayer
ScoreBoardController "1"--|>"1..4" IPlayer
IWinkToken "1"<|--|>"1" IPlayer
FirstSheep --|>"1..4" IPlayer
ISheepToken "1"<|--|>"1" IPlayer
IPillowToken "1"<|--|>"1" IPlayer
IZzzToken "10" <|--|> "1"IPlayer
ReferenceTile --|>"1..4" IPlayer
NightmareToken --|> IFence
WinkToken --|> IPillowToken
IDreamTile "1"--|>"0..40" IZzzToken
DreamTileDeck "1"--|>"0..*" IDreamTile
CardDeck "1"--|>"0..*" Card
Phase --|> IResetable:use


Phase --|> NightmareReferenceCard
SinisterSpider --|> IWebToken
Phase --|> Deck
GameBoard --|> Deck

Hand --|> Card
CardDeck "1"--|>"0..*" Card
NightmareReferenceCard --|> Card: use

Player --|> GameBoard
GameBoard --|> IDreamTile
IWebToken --|> Stuckable:use
SheepToken --|> IFence


IPlayer "1"<|--|>"10" IZzzToken

NightmareToken --|>"1" IScare
DreamTile --|>"1" IScare

Player --|> IHand: use

Deck --|> DrawFromDeck


'TODO: Switchable connection'
Phase --|> SwitchPhase



}



@enduml
